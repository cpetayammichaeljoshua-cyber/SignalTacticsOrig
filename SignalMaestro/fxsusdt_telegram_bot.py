
#!/usr/bin/env python3
"""
FXSUSDT.P Telegram Signal Bot
Sends Ichimoku Sniper signals to @SignalTactics channel with Cornix compatibility
"""

import asyncio
import logging
import aiohttp
import os
from datetime import datetime, timedelta
from typing import Dict, Any, Optional
import json

from ichimoku_sniper_strategy import IchimokuSniperStrategy, IchimokuSignal
from fxsusdt_trader import FXSUSDTTrader

class FXSUSDTTelegramBot:
    """Telegram bot for FXSUSDT.P signals"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # Telegram Configuration
        self.bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
        self.channel_id = "@SignalTactics"
        self.admin_chat_id = os.getenv('ADMIN_CHAT_ID')  # Optional admin notifications
        
        if not self.bot_token:
            raise ValueError("Missing TELEGRAM_BOT_TOKEN in Replit secrets")
        
        # Components
        self.strategy = IchimokuSniperStrategy()
        self.trader = FXSUSDTTrader()
        
        # Telegram API
        self.base_url = f"https://api.telegram.org/bot{self.bot_token}"
        
        # Rate limiting
        self.last_signal_time = None
        self.min_signal_interval = timedelta(minutes=30)  # Minimum 30 minutes between signals
        
        self.logger.info("ğŸ¤– FXSUSDT Telegram Bot initialized")
    
    async def send_message(self, chat_id: str, text: str, parse_mode: str = 'Markdown') -> bool:
        """Send message to Telegram chat/channel"""
        try:
            url = f"{self.base_url}/sendMessage"
            data = {
                'chat_id': chat_id,
                'text': text,
                'parse_mode': parse_mode,
                'disable_web_page_preview': True
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data) as response:
                    if response.status == 200:
                        result = await response.json()
                        if result.get('ok'):
                            self.logger.info(f"âœ… Message sent to {chat_id}")
                            return True
                        else:
                            self.logger.error(f"âŒ Telegram API error: {result.get('description')}")
                            return False
                    else:
                        self.logger.error(f"âŒ HTTP error: {response.status}")
                        return False
                        
        except Exception as e:
            self.logger.error(f"Error sending message: {e}")
            return False
    
    def format_cornix_signal(self, signal: IchimokuSignal) -> str:
        """Format signal for Cornix compatibility"""
        
        # Determine direction emoji
        direction_emoji = "ğŸŸ¢" if signal.action == "BUY" else "ğŸ”´"
        
        # Calculate risk/reward percentages
        entry = signal.entry_price
        sl = signal.stop_loss
        tp = signal.take_profit
        
        if signal.action == "BUY":
            sl_percent = abs((entry - sl) / entry) * 100
            tp_percent = abs((tp - entry) / entry) * 100
        else:
            sl_percent = abs((sl - entry) / entry) * 100
            tp_percent = abs((entry - tp) / entry) * 100
        
        cornix_signal = f"""
{direction_emoji} **ICHIMOKU SNIPER - FXSUSDT.P**

**ğŸ“Š SIGNAL DETAILS:**
â€¢ **Pair:** `FXSUSDT.P`
â€¢ **Direction:** `{signal.action}`
â€¢ **Entry:** `{entry:.5f}`
â€¢ **Stop Loss:** `{sl:.5f}` (-{sl_percent:.2f}%)
â€¢ **Take Profit:** `{tp:.5f}` (+{tp_percent:.2f}%)

**âš™ï¸ TRADING PARAMETERS:**
â€¢ **Leverage:** `Auto (Dynamic)`
â€¢ **Risk/Reward:** `1:{signal.risk_reward_ratio:.1f}`
â€¢ **Timeframe:** `30 Minutes`
â€¢ **Strategy:** `Ichimoku Cloud Sniper`

**ğŸ“ˆ SIGNAL ANALYSIS:**
â€¢ **Strength:** `{signal.signal_strength:.1f}%`
â€¢ **Confidence:** `{signal.confidence:.1f}%`
â€¢ **ATR Value:** `{signal.atr_value:.6f}`

**ğŸ¯ CORNIX COMPATIBLE FORMAT:**
```
FXSUSDT.P {signal.action}
Entry: {entry:.5f}
SL: {sl:.5f}
TP: {tp:.5f}
Leverage: Auto
```

**â° Signal Time:** `{signal.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}`
**ğŸ¤– Bot:** `TradeTactics - Ichimoku Sniper`

*Automated signal generated by Ichimoku Cloud analysis*
        """.strip()
        
        return cornix_signal
    
    async def send_signal_to_channel(self, signal: IchimokuSignal) -> bool:
        """Send signal to @SignalTactics channel"""
        try:
            # Check rate limiting
            if self.last_signal_time:
                time_since_last = datetime.now() - self.last_signal_time
                if time_since_last < self.min_signal_interval:
                    remaining = self.min_signal_interval - time_since_last
                    self.logger.info(f"â³ Rate limit active, {remaining.total_seconds():.0f}s remaining")
                    return False
            
            # Format signal for Cornix
            formatted_signal = self.format_cornix_signal(signal)
            
            # Send to channel
            success = await self.send_message(self.channel_id, formatted_signal)
            
            if success:
                self.last_signal_time = datetime.now()
                self.logger.info(f"ğŸ“¡ Signal sent to {self.channel_id}: {signal.action} FXSUSDT.P @ {signal.entry_price:.5f}")
                
                # Send to admin if configured
                if self.admin_chat_id:
                    admin_msg = f"âœ… Signal sent to {self.channel_id}\n{signal.action} FXSUSDT.P @ {signal.entry_price:.5f}"
                    await self.send_message(self.admin_chat_id, admin_msg)
                
                return True
            else:
                self.logger.error("âŒ Failed to send signal to channel")
                return False
                
        except Exception as e:
            self.logger.error(f"Error sending signal to channel: {e}")
            return False
    
    async def send_status_update(self, message: str) -> bool:
        """Send status update to admin"""
        if self.admin_chat_id:
            return await self.send_message(self.admin_chat_id, f"ğŸ¤– **FXSUSDT Bot Status**\n\n{message}")
        return True
    
    async def test_telegram_connection(self) -> bool:
        """Test Telegram bot connection"""
        try:
            url = f"{self.base_url}/getMe"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        result = await response.json()
                        if result.get('ok'):
                            bot_info = result.get('result', {})
                            bot_name = bot_info.get('username', 'Unknown')
                            self.logger.info(f"âœ… Telegram connection successful: @{bot_name}")
                            return True
                        
            return False
            
        except Exception as e:
            self.logger.error(f"âŒ Telegram connection test failed: {e}")
            return False
    
    async def scan_and_signal(self) -> bool:
        """Scan market and send signal if conditions are met"""
        try:
            self.logger.info("ğŸ” Scanning FXSUSDT.P for Ichimoku signals...")
            
            # Get 30m market data
            market_data = await self.trader.get_30m_klines(limit=200)
            if not market_data:
                self.logger.warning("âŒ No market data available")
                return False
            
            # Generate signal
            signal = await self.strategy.generate_signal(market_data)
            if not signal:
                self.logger.info("ğŸ“Š No qualifying signal found")
                return False
            
            # Send signal to channel
            success = await self.send_signal_to_channel(signal)
            
            if success:
                self.logger.info(f"ğŸ¯ Successfully processed {signal.action} signal")
                return True
            else:
                self.logger.error("âŒ Failed to send signal")
                return False
                
        except Exception as e:
            self.logger.error(f"Error in scan and signal: {e}")
            return False
    
    async def run_continuous_scanner(self):
        """Run continuous market scanner"""
        self.logger.info("ğŸš€ Starting FXSUSDT.P continuous scanner...")
        
        # Initial connection tests
        if not await self.trader.test_connection():
            self.logger.error("âŒ Binance API connection failed")
            return
        
        if not await self.test_telegram_connection():
            self.logger.error("âŒ Telegram connection failed")
            return
        
        # Send startup notification
        await self.send_status_update("ğŸš€ FXSUSDT.P Ichimoku Sniper Bot started\nğŸ“Š Monitoring 30-minute timeframe\nğŸ¯ Ready for signals")
        
        scan_interval = 300  # 5 minutes
        
        try:
            while True:
                try:
                    await self.scan_and_signal()
                except Exception as e:
                    self.logger.error(f"Error in scan cycle: {e}")
                
                # Wait for next scan
                self.logger.debug(f"â±ï¸ Waiting {scan_interval}s for next scan...")
                await asyncio.sleep(scan_interval)
                
        except KeyboardInterrupt:
            self.logger.info("ğŸ‘‹ Scanner stopped by user")
            await self.send_status_update("ğŸ›‘ FXSUSDT.P Bot stopped")
        except Exception as e:
            self.logger.error(f"âŒ Critical error in scanner: {e}")
            await self.send_status_update(f"âŒ Bot error: {e}")

async def main():
    """Main function to run the FXSUSDT bot"""
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    bot = FXSUSDTTelegramBot()
    await bot.run_continuous_scanner()

if __name__ == "__main__":
    asyncio.run(main())
